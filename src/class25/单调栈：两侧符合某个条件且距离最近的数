单调栈：两侧符合某个条件且距离最近的数

一种特别设计的栈结构，为了解决如下的问题：

给定一个可能含有重复值的数组arr，i位置的数一定存在如下两个信息
1）arr[i]的左侧离i最近并且小于(或者大于)arr[i]的数在哪？
2）arr[i]的右侧离i最近并且小于(或者大于)arr[i]的数在哪？
如果想得到arr中所有位置的两个信息，怎么能让得到信息的过程尽量快。

那么到底怎么设计呢？

设计理念类似于双端队列，后面的数决定前面的数的去留。

一、假设arr中没有重复值：

生成一个栈，栈中的数从底部到顶部严格从小到大
遍历arr，到了i位置的数。将arr[i]与栈顶x比较
如果arr[i]>arr[x], i 压入栈
如果arr[i]<arr[x], x 需要弹出，弹出的时候生成信息：
    1. 右侧最近的比arr[x]小的数:arr[i]
    2. 左侧最近的比arr[x]小的数:新的栈顶y的值arr[y]
继续将arr[i]与新的栈顶y的值arr[y]比较，流程同上。
....
来到了arr末尾，将栈中的数依次弹出，这时候只有左侧最近的比当前弹出的小的数
栈中的最后一个数z:没有右侧最近的比z小的数，也没有左侧最近的比z小的数

以上复杂度：所有的数最多进栈一次，出栈一次，O(N)

二、arr中有重复值：
流程同上，不同点：
1. 压入栈的不再是单个index，而是值相同的index组成的链表
2. 与栈顶比较时，是与栈顶链表任意位置代表的数比较
3. 栈顶弹出结算时，一个链表的结算信息是一样的。离它左边最近小于它的值，是下方链表的最后一个位置
