技巧：位图解决某一范围上数字的出现情况，并可以节省大量空间

题目2
32位无符号整数的范围是0~4,294,967,295，
现在有一个正好包含40亿个无符号整数的文件，
所以在整个范围中必然存在没出现过的数。
可以使用最多1GB的内存，怎么找到所有未出现过的数？
解题：
    统计一个数有没有出现，只要记录两个状态，true or false
    所以bitMap就可以实现，一个长度为2^32（约42亿）的bitMap数组，内存为2^32/8byte,约536M
    用bit的0、1来标记一个数有没有出现。
如何标记呢？
    申请一个int[] arr,长度为2^32/32
    假设需要标记数字x，
    i=x/32:得到需要访问的int：arr[i]
    b=i%32:得到需要访问该int的位状态：(arr[i] & 1<<b)==1?


技巧：利用分段统计思想、并进一步节省大量空间

【进阶】
内存限制为 3KB，但是只用找到一个没出现过的数即可
解题：
    因为内存只有3kb,标记每个数的状态是不可能了，只能将0~2^32-1分成若干的范围，看每个范围的状态是不是满员
    3kb=3000b
    3000/4=750,即最多能容纳750个int。
    这里去一个2^x的整数，即512，所以申请一个512长度的int[] arr,每个int记录一个范围中出现的数的个数
    一个范围的长度就是2^32/512 = 8388608
    所以统计完，看arr中哪个位置的数不足8388608，就定位到了这个数字代表的长度为8388608的范围内不满员
    再针对该范围再划分，
    一个范围的长度就是8388608/512=16384
    所以统计完，看arr中哪个位置的数不足16384，...
    ...
    直到最后拿到一个512长度的范围内，某个位置不足1，就找到这个数

    
【进阶2】
内存限制为有限几个变量，但是只用找到一个没出现过的数即可
解题：
    解题方式和之前一样，只是这次用变量来控制范围：
    L：左边界
    R：右边界
    mid：中位数
    countL: 左边界出现的数的个数
    countR: 右边界出现的数的个数
    第一轮看countL、countR哪个不满2^31
    第一轮看countL、countR哪个不满2^30
    ...
总结：
    3kb内存：实行512分法
    有限几个变量：实行2分法


题目3：
有一个包含100亿个URL的大文件，假设每个URL占用64B，
请找出其中所有重复的URL
【补充】
某搜索公司一天的用户搜索词汇是海量的(百亿数据量)，
请设计一种求出每天热门Top100词汇的可行办法
解题：
    允许误差：布隆过滤器
    不允许误差：将url哈希分流到各个小文件，在小文件中查出重复的url


题目4：
32位无符号整数的范围是0~4294967295，
现在有40亿个无符号整数，
可以使用最多1GB的内存，
找出所有出现了两次的数。
解题：
    bitMap中两个位来表示一个数的状态：
    00：出现0次
    01：出现1次
    10：出现2次
    11：出现3+次
    需要一个长度为2^33长度的bitMap，内存恐怕超过1G
怎么办？
    用范围将0~2^32-1分成两个范围，分两次统计，一定不超过1G

题目5
32位无符号整数的范围是0~4294967295，现在有40亿个无符号整数
可以使用最多3K的内存，怎么找到这40亿个整数的中位数？
解题：
    仍然是成512段来统计每一段的数字个数。
    求40亿个整数的中位数，就是求第20亿个数，所以从第一段统计的个数开始累加，当某个范围加进去，累计超过20亿时，中位数一定在该范围内
    假设前面的范围已经累加了x个了，那就求该范围中第20亿-x个数。继续采用分段。直到每一段的范围代表1个数为止


技巧：利用堆、外排序来做多个处理单元的结果合并
题目6
32位无符号整数的范围是0~4294967295，
有一个10G大小的文件，每一行都装着这种类型的数字，
整个文件是无序的，给你5G的内存空间，
请你输出一个10G大小的文件，就是原文件所有数字排序的结果
解题：
    用一个空间不超过5g的大根堆，遍历一遍文件，得到排名前x小的数字，以及每个数字的个数
    将大根堆的记录生成文件，记录此时前x小的最大数字w，之后释放内存
    再遍历一遍文件，得到除了小于等于w的数外，排名前x小的数字
    将大根堆的记录生成文件...
    ...
    直到堆收不满了，堆里数生成文件后就可以停止了



理解外排序：
32位无符号整数的范围是0~4294967295，
有一个10G大小的文件，每一行都装着这种类型的数字，
整个文件是无序的，给你5G的内存空间，
请你输出从小到大，排名前k个的数

外排：
    将所有的数哈希分类，分成10个小文件，各自排序。
    拿到结果以后，将每个文件排名第一的拿出来再pk，
    每个文件第一名被拿掉后第二名立刻顶上去
    凑满k个为止
