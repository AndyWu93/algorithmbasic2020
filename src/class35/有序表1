索引
数据库中一切能够建立索引的字段都是可排序的
索引就是将索引字段的值组成搜索二叉树的结构，在查找该字段的时候，能够快速找到，最多遍历一颗树的高度O(logN)
问：为什么不用hash表？
    因为不仅需要查一条记录，有时候需要查找一个范围的记录，所以用有序表
有序表就是平衡搜索二叉树，种类：
    avl，SizeBalanceTree，红黑树
平衡搜索二叉树如何平衡？
左旋：
    以x为头节点的左旋：x下去，x.right(y)上来，x成为y.left,y原来的left成为新的x.right
右旋：
    以x为头节点的右旋：x下去，x.left(z)上来，x成为z.right,z原来的right成为新的x.left
左旋右旋不改变树的搜索性，但调整了树的平衡

BST的增删查：
增：
    从头节点开始，遇到大的往左滑，遇到小的往右滑，直到来到一个null的位置，停
查：
    从头节点开始，遇到大的往左滑，遇到小的往右滑，直到来到相等的位置，停
删除节点x：
    1）x没有左右子树：直接删掉
    2）x仅有左/右一个子树：删掉后，左或者右孩子替代原有位置
    3）x既有左子树，又有右子树：
        找到x节点右子树最左位置a节点，
        用a来替代该节点的环境，
        a原来的right替代a原来的环境
    为什么这么操作？a节点是x节点右树最小的位置，也就是>x最近的节点
    所以也可以用x左树的最右节点y节点来替x的环境


AVL树：拥有最严苛的平衡性
    任何一个节点的左树和右树的高度差<2
avl树增删节点后，平衡性被破坏的4中情况：
LL: 左树的左树过长了，解决方案：头节点1次右旋
LR: 左树的右树过长了，
    解决方案：让左树的右树来到头节点的位置
    步骤：（LR->LL->平）
        1.针对左树来1次左旋，
        2.针对头节点来1次右旋
RL: 右树的左树过长了，
    解决方案：让右树的左树来到头节点的位置
    步骤：（RL->RR->平）
        1.针对右树来1次右旋，
        2.针对头节点来1次左旋
RR: 右树的右树过长了，解决方案：头节点1次左旋

LL+LR: 左树的左树、左树的右树都长了，解决方案：按照LL处理
RL+RR: 右树的左树、右树的右树都长了，解决方案：按照RR处理

AVL树的调整模式：
 加入一个节点x
    看以x为头的树是否需要调整
    再看以x的父节点为头的树是否需要调整
    ...
    一直到整颗树的头。
 调整代价：
    加入的节点沿途都需要调整O(logN)
    每次调整复杂度O(1)
    整体复杂度：O(logN)

 删除一个节点x
    1）x没有左右子树：删掉后，沿途查看所有父节点看是否需要调整
    2）x仅有左/右一个子树：删掉后，沿途查看替代自己环境的节点和所有父节点看是否需要调整
    3）x既有左子树，又有右子树：从原右树的最左节点的父节点开始沿途查看是否需要调整


思考：做题时改有序表，一般该的是那部分内容？
    avl是有序表的一种实现，有序表的功能就是bst的功能，这些功能不涉及平衡性的变动。
    平衡性就像是个补丁，需要再适合的时候调用即可