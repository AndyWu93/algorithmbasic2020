卡特兰数
k(0) = 1, k(1) = 1时，如果接下来的项满足：
k(n) = k(0) * k(n - 1) + k(1) * k(n - 2) + ... + k(n - 2) * k(1) + k(n - 1) * k(0)
或者
k(n) = c(2n, n) - c(2n, n-1)
或者
k(n) = c(2n, n) / (n + 1)
就说这个表达式，满足卡特兰数，常用的是范式1和2，3几乎不会使用到

公式一
k(n) = k(0) * k(n - 1) + k(1) * k(n - 2) + ... + k(n - 2) * k(1) + k(n - 1) * k(0)
场景:
n个无差别节点，选取任意个组成二叉树，有几种组合方式
个数  组合数
0     1
1     1
...
10    左树0个去组合，右树9个去组合，结果相乘
    + 左树1个去组合，右树8个去组合，结果相乘
    ...


公式二
k(n) = c(2n, n) - c(2n, n-1)
场景1：（经典场景）
n个0和n个1能够组成多少个合法前缀（合法：每个任意长度的前缀0比1多或相等）
假设有集合A，里面都是n个0和n个1的非法前缀
拿其中一个元素分析，
假设n=3，其中一个如下
011001
第一个非法数是第3个数，切开，
011 001
前面1比0多一个，后面0比1多一个
后面的数0-1转换得到
011 110
于是，前面1比0多一个，后面还是1比0多一个
这样转换后，总能发现
转换后的数都是唯一的，所以转换后的数就组成了集合B
集合B中，是n+1个1，n-1个0，组成的任意组合，总数为c(2n,n+1),或者c(2n,n-1)。
c(2n,n+1)含义：在2n个格子中任意拿出n+1个格子放1，有几种方式
c(2n,n)含义：在2n个格子中任意拿出n个格子放1，有几种方式
c(2n,n)（所有的方式）- c(2n,n+1)（非法的方式）
思考：为什么可以将A集合转换为B集合计算？
    A集合的任意一个元素通过某个函数（第一个非法位置开始往后的数都反转）得到B集合的一个与之对应的元素
    B集合的任意一个元素通过某个函数（第一个非法位置开始往后的数都反转）得到A集合的一个与之对应的元素
    所以A集合和B集合是一一映射，数量一定相等。


场景2：
n个对象（对象都一样），操作进栈和出栈，一定是要进n个对象出n个对象，一共几种方式
比如n=3
入入入出出出
入出入出入出
规律：每个前缀入>=出


