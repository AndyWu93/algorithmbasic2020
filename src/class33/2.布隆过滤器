布隆过滤器

通过哈希采样的方式过滤掉黑名单，极大的节省了空间。注意这种方式有可能错杀，失误率1/10000

工程举例：
1. 100亿个url，每个url为64byte，设计一个方案过滤掉这100亿个url。
如果用hashmap，需要640G的内存，布隆过滤器可能只需要20G

2. 多个爬虫一起工作，每个爬虫将爬过的url放入一个黑名单中，其他爬虫爬之前看下这个url在不在黑名单里，在的话直接跳过


实现方式：bitMap
一个int 4个byte
一个byte 8个bit
实现举例：
    准备一个长度为m的位图数组(空间=m/8byte),
    准备3个hash函数，每个函数对样本计算哈希值以后，%m得到一个值，将该值在m中对应的1个位置描黑（0变成1）
    3个函数得到3个位置，都描黑
如何查询？
    对一个样本，用同样的3个哈希函数得到3个位置，看在位图中是不是都是描黑的，只有3个都黑的才是true，其他都是false
核心问题：
    m定多大？m太大浪费空间，太小都描黑了无法区分。m越大失误率越低
    多少个哈希函数？太多，m会迅速耗尽，失误率上升，太小，采样不足，失误率上升
m相关的变量：
    1.样本量
    2.失误率

布隆过滤器重要的三个公式（最好背下来）
1，假设数据量为n，预期的失误率为p（布隆过滤器大小和每个样本的大小无关）
2，根据n和p，算出Bloom Filter一共需要多少个bit位，向上取整，记为m
3，根据m和n，算出Bloom Filter需要多少个哈希函数，向上取整，记为k
4，根据修正公式，算出真实的失误率p_true

当样本量n一定，失误率p越小，需要的bit长度m越大，代入失误率可的得到bit长度：
    m = - (n * ln p)/(ln 2)^2
哈希函数个数k越少，失误率p越大，哈希函数个数k越多，失误率p越大，只有k取一个中间的值，失误率才稳定。
代入bit长度和样本量可以得到最佳哈希函数个数
    k = ln 2 * m/n = 0.7 * m/n
最终采用实际bit长度，和哈希函数个数，代入可得到实际的失误率，bit长度越大，失误率越低
    p = (1 - e^(-(n*k)/m))^k

面试技巧：
    可有询问面试官，该设计是否允许有失误率，允许的话就是布隆过滤器

哈希函数准备技巧：
    准备两个哈希函数f1,f2,可以通过a*f1+b*f2的方式得到任意个哈希函数

工程举例：
    hdfs的每个数据块都有一个boolean过滤器，里面的数据都在布隆过滤器中留下痕迹。
    当要来查找某个数据时，可以通过布隆过滤器确认一下该数据块里有没有，
    没有的话就不用找了，有的话再尝试找一下，有可能不在里面。





